[ORG 0x00]		; 코드의 시작 어드레스를 0x00으로 설정
[BITS 16]		; 이하의 코드는 16비트 코드로 설정

SECTION .text		; text 섹션(세그먼트)을 정의

jmp 0x1000:START	; CS세그먼트 레지스터에 0x1000을 복사하면서, START레이블로 이동

SECTORCOUNT:		dw 0x0000	; 현재 실행중인 섹터번호를 저장
TOTALSECTORCOUNT	equ 1024	; 가상 os의 총 섹터수
					; 최대 1152섹터(0x90000byte)까지 가능

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 코드영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
START:
	mov ax, cs			; CS세그먼트 레지스터의 값을 AX레지스터에 설정
	mov ds, ax			; AX레지스터의 값을 DS세그먼트레지스터에 설정
	mov ax, 0xB800			; 비디오 메모리 어드레스인 0x0B8000을 세그먼트 레지스터값으로 변환
	mov es, ax			; es세그먼트 레지스터에 설정

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 각 섹터별로 코드를 생성
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	%assign i 0			; i라는 변수를 지정하고 0으로 초기화
	%rep TOTALSECTORCOUNT		; TOTALSECTORCOUNT에 저장된 값만큼 아래 코드를 반복
		%assign i i + 1		; i를 1증가
	
		; 현재 실행중인 코드가 포함된 섹터의 위치를 화면 좌표로 변환
		mov ax, 2			; 한문자를 나타내는 바이트수(2)를 ax에 설정
		mul word [ SECTORCOUNT ]	; ax레지스터와 섹터 수를 곱함
		mov si, ax			; 곱한 결과를 si에 설정

		; 계산된 결과를 비디오메모리에 오프셋으로 삼아 세번째 라인부터 화면에 0을 출력
		mov byte [ es : si + ( 160 * 2) ], '0' + ( i % 10 )
		add word [ SECTORCOUNT ], 1	; 섹터 수를 1증가
	
		; 마지막 섹터이면 더 수행할 섹터가 없으므로 무한 루프 수행, 
		; 그렇지 않으면 다음 섹터로 이동해서 코드 수행
		%if i == TOTALSECTORCOUNT	; i가 TOTALSECTORCOUNT와 같다면(마지막 섹터라면)
			mov byte [ es: si +(160 *2) ], 'e'
			jmp $			; 현재위치에서 무한루프 수행
		%else				; 마지막섹터가 아니면
			jmp ( 0x1000 + i * 0x20 ): 0x0000	; 다음 섹터 오프셋으로 이동
		%endif

		times ( 512 - ( $ - $$ ) % 512 ) db 0x00
	%endrep
